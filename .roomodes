{
  "customModes": [
    {
      "slug": "go-module",
      "name": "Go:Module",
      "roleDefinition": "\n## 実装モード: モジュールモード\n\nモジュールモードはディレクトリの下で複数のファイルで構成される。\n\n例\n\n```\npkg/\n  xxx/\n    xxx.go       - パッケージのメイン実装\n    xxx_test.go  - テスト\n    types.go     - 型定義\n    errors.go    - エラー定義\n    mock.go      - テスト用モック\ninternal/\n  yyy/\n    yyy.go       - 内部パッケージの実装\n    yyy_test.go  - テスト\n    types.go     - 型定義\n    errors.go    - エラー定義\ncmd/\n  app/\n    main.go      - エントリーポイント\n```\n\nモジュールをテストする時は、 `go test ./...` または `go test ./pkg/xxx` のように実行する。\n\nテストが落ちた時は、次の手順を踏む。\n\n機能追加の場合\n\n1. 機能追加の場合、まず `go test ./...` で全体のテストが通過しているかを確認する\n2. 修正後、対象のパッケージをテストする\n\n修正の場合\n\n1. `go test ./pkg/xxx` でパッケージのテストを実行する\n2. 落ちたパッケージのテストを確認し、実装を参照する。\n   - テストは一つずつ実行する `go test -run TestFunctionName ./pkg/xxx`\n3. 落ちた理由をステップバイステップで考える(闇雲に修正しない!)\n4. 実装を修正する。必要な場合、実行時の過程を確認するためのプリントデバッグを挿入する。\n5. パッケージのテスト実行結果を確認\n   - 修正出来た場合、プリントデバッグを削除する\n   - 修正できない場合、3 に戻る。\n6. パッケージ以外の全体テストを確認\n\nテストが落ちた場合、落ちたテストを修正するまで次のパッケージに進まない。\n\n### モジュール構造とパッケージ設計\n\nGoのモジュール構造は、標準的なレイアウトに従うことが推奨されます：\n\n1. **cmd/**\n   - 実行可能なアプリケーションのメインパッケージ\n   - 各サブディレクトリは独立した実行可能ファイルに対応\n   - 最小限のコードのみを含み、ロジックは他のパッケージに委譲\n\n2. **internal/**\n   - 外部からインポートできない非公開パッケージ\n   - アプリケーション固有のロジック\n   - 再利用を意図していないコード\n   - internalディレクトリには直接ファイルを置くことも可能（サブディレクトリを作る必要はない）\n\n3. **pkg/**\n   - 外部からインポート可能な公開パッケージ\n   - 再利用可能なライブラリコード\n   - 安定したAPIを提供\n\n4. **その他のディレクトリ**\n   - `api/`: プロトコル定義、OpenAPI/Swagger仕様など\n   - `configs/`: 設定ファイルテンプレート\n   - `docs/`: ドキュメント\n   - `test/`: 追加のテストとテストデータ\n\n### パッケージの役割とコンテキスト境界\n\n各パッケージは明確な責任を持ち、単一の目的を果たすべきです：\n\n1. **パッケージの命名**\n   - 短く、明確で、説明的な名前\n   - 単数形を使用（`user`、`order`など）\n   - 汎用的すぎる名前を避ける（`util`、`common`など）\n\n2. **パッケージの構成**\n   - 関連する機能をグループ化\n   - 循環依存を避ける\n   - 依存方向を上位レベルから下位レベルに向ける\n\n3. **ファイル構成**\n   - 機能ごとに適切にファイルを分割\n   - `types.go`: 型定義\n   - `errors.go`: エラー定義\n   - `\u003cpackage\u003e_test.go`: テスト\n   - `mock.go`: テスト用モック\n\n### インターフェースの設計\n\nインターフェースは使用側のパッケージで定義することが推奨されます：\n\n```go\n// service/user.go（使用側）\npackage service\n\ntype UserRepository interface {\n    GetByID(id string) (*User, error)\n    Save(user *User) error\n}\n\ntype UserService struct {\n    repo UserRepository\n}\n\n// repository/user.go（実装側）\npackage repository\n\ntype UserRepo struct {\n    db *sql.DB\n}\n\n// UserServiceのインターフェースを満たすメソッド\nfunc (r *UserRepo) GetByID(id string) (*service.User, error) {\n    // 実装\n}\n\nfunc (r *UserRepo) Save(user *service.User) error {\n    // 実装\n}\n```\n\nこの方法により：\n- 依存方向が明確になる（上位レベルのパッケージは下位レベルのパッケージに依存しない）\n- モックの作成が容易になる\n- 循環依存を避けられる\n\n### 依存関係の管理\n\n1. **go.mod と go.sum**\n   - `go.mod`: モジュール定義と依存関係\n   - `go.sum`: 依存関係のチェックサム\n   - バージョン管理と再現性の確保\n\n2. **依存関係の追加**\n   ```bash\n   go get --tool github.com/example/package@v1.2.3\n   ```\n\n3. **依存関係の更新**\n   ```bash\n   go get --tool -u github.com/example/package\n   ```\n\n4. **未使用の依存関係の削除**\n   ```bash\n   go mod tidy\n   ```\n\n### テスト戦略\n\n1. **テーブル駆動テスト**\n   - データとロジックを分離\n   - 複数のテストケースを効率的に記述\n\n2. **テストヘルパーとモック**\n   - テスト用のヘルパー関数\n   - インターフェースを使用したモック\n   - `mock.go` ファイルでのモック実装\n\n3. **テストカバレッジ**\n   ```bash\n   go test -coverprofile=coverage.out ./...\n   go tool cover -html=coverage.out\n   ```\n\n4. **ベンチマーク**\n   ```go\n   func BenchmarkFunction(b *testing.B) {\n       for i := 0; i \u003c b.N; i++ {\n           // テスト対象の関数呼び出し\n       }\n   }",
      "groups": [
        "read",
        "edit",
        "browser",
        "command",
        "mcp"
      ],
      "source": "project",
      "__filename": "/Users/matsumotokazuki/Desktop/work/graffity/Centray/application/state_sample/.cline/roomodes/go-module.md"
    },
    {
      "slug": "go-refactor",
      "name": "Go:RefactorMode",
      "roleDefinition": "\n## リファクターモード\n\nリファクターモードは、既存のコードを改善するためのモードです。\n\n### 静的解析ツールの活用\n\n1. **go vet**\n   - 標準の静的解析ツール\n   - 潜在的なバグや問題を検出\n   ```bash\n   go vet ./...\n   ```\n\n2. **golangci-lint**\n   - 複数のリンターを統合したツール\n   - コードスタイル、潜在的なバグ、パフォーマンス問題などを検出\n   ```bash\n   golangci-lint run --enable=gocognit,gocritic,gocyclo,godot,godox,misspell\n   ```\n\n### デッドコードの検出\n\n1. **未使用のコード**\n   - 未使用の変数、関数、型などを検出\n   ```bash\n   go vet -unusedresult ./...\n   ```\n\n2. **未使用の依存関係**\n   - 未使用のインポートパッケージを検出\n   ```bash\n   go mod tidy\n   ```\n\n3. **サードパーティツール**\n   - より高度な静的解析\n   ```bash\n   staticcheck ./...\n   ```\n\n### リファクタリングの手順\n\n1. **テストの確認**\n   - リファクタリング前にすべてのテストが通過することを確認\n   ```bash\n   go test ./...\n   ```\n\n2. **コードの分析**\n   - 静的解析ツールを実行\n   - 複雑度の高い部分を特定\n   - 重複コードを特定\n\n3. **リファクタリングの実施**\n   - 小さな変更を段階的に行う\n   - 各変更後にテストを実行\n   - コードの動作を変えないよう注意\n\n4. **最終確認**\n   - すべてのテストが通過することを確認\n   - 静的解析ツールを再実行\n   - パフォーマンスの確認（必要に応じて）\n\n### リファクタリングの種類\n\n1. **コードの整理**\n   - 命名の改善\n   - コメントの追加・更新\n   - フォーマットの統一\n\n2. **構造の改善**\n   - 関数の分割\n   - インターフェースの抽出\n   - 責任の分離\n\n3. **パフォーマンスの最適化**\n   - アルゴリズムの改善\n   - メモリ使用量の削減\n   - 並行処理の導入\n\n### リファクタリングのベストプラクティス\n\n1. **テストファーストアプローチ**\n   - リファクタリング前にテストを充実させる\n   - テストカバレッジを確認\n\n2. **段階的な変更**\n   - 一度に大きな変更を行わない\n   - 各ステップでテストを実行\n\n3. **バージョン管理の活用**\n   - 小さなコミットに分ける\n   - 明確なコミットメッセージを書く\n\n4. **ドキュメントの更新**\n   - 変更に合わせてドキュメントを更新\n   - APIの変更がある場合は特に注意",
      "groups": [
        "read",
        "edit",
        "browser",
        "command",
        "mcp"
      ],
      "source": "project",
      "__filename": "/Users/matsumotokazuki/Desktop/work/graffity/Centray/application/state_sample/.cline/roomodes/go-refactor.md"
    },
    {
      "slug": "go-script",
      "name": "Go:ScriptMode",
      "roleDefinition": "\n## 実装モード: スクリプトモード\n\n- 外部依存を可能な限り減らして、一つのファイルに完結してすべてを記述する\n- テストコードも同じファイルに記述する\n- スクリプトモードは `// @script` がコード中に含まれる場合、あるいは `scripts/*` や `script/*` 以下のファイルが該当する\n\nスクリプトモードの例\n\n```go\n// @script\npackage main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n/**\n * 足し算を行うモジュール\n */\nfunc add(a, b int) int {\n\treturn a + b\n}\n\n// メイン関数（go run add.go で動作確認するエントリポイント）\nfunc main() {\n\tfmt.Println(add(1, 2))\n}\n\n// テスト関数\nfunc TestAdd(t *testing.T) {\n\t// テストケース\n\tt.Run(\"add(1, 2) = 3\", func(t *testing.T) {\n\t\tresult := add(1, 2)\n\t\tassert.Equal(t, 3, result, \"sum of 1 + 2 should be 3\")\n\t})\n}\n```\n\nCLINE/Rooのようなコーディングエージェントは、まず `go run add.go` で実行して、要求に応じて `go test add.go` で実行可能なようにテストを増やしていく。\n\nスクリプトモードでは標準ライブラリの使用を優先し、必要最小限の外部依存のみを許可する。\n\n優先順位:\n\n- 標準ライブラリ\n- よく知られた安定したライブラリ（testify、yaml.v3など）\n- その他の外部ライブラリ\n\n```go\n// OK\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"gopkg.in/yaml.v3\"\n)\n\n// 必要に応じて他のライブラリも使用可能\nimport (\n\t\"github.com/spf13/cobra\"\n\t\"github.com/pkg/errors\"\n)\n```\n\n最初にスクリプトモードで検証し、モジュールモードに移行していく。\n\n### Goスクリプトモードの特徴\n\n1. **単一ファイル構成**\n   - 1つのファイルに機能とテストを含める\n   - `package main` と `func main()` を含める\n   - 実行可能なスタンドアロンプログラムとして動作\n\n2. **テスト実行方法**\n   - `go test \u003cfilename\u003e.go` でテスト実行\n   - テスト関数は `func Test\u003cName\u003e(t *testing.T)` の形式で定義\n\n3. **依存関係の管理**\n   - 標準ライブラリを優先的に使用\n   - 外部依存は最小限に抑える\n   - 必要な場合は `go.mod` に依存関係を追加\n\n4. **実行方法**\n   - `go run \u003cfilename\u003e.go` で直接実行\n   - 必要に応じて引数を渡す: `go run \u003cfilename\u003e.go arg1 arg2`",
      "groups": [
        "read",
        "edit",
        "browser",
        "command",
        "mcp"
      ],
      "source": "project",
      "__filename": "/Users/matsumotokazuki/Desktop/work/graffity/Centray/application/state_sample/.cline/roomodes/go-script.md"
    },
    {
      "slug": "go-tdd",
      "name": "Go:TestFirstMode",
      "roleDefinition": "\n## 実装モード: テストファーストモード\n\nテストファーストモードは、実装のインターフェース定義とテストコードを先に書き、それをユーザーに確認を取りながら実装を行う。\n\nファイル冒頭に `// @tdd` を含む場合、それはテストファーストモードである。\n\n### テストの命名規約\n\nテスト名は以下の形式で記述する：\n\n```\n「{状況}の場合に{操作}をすると{結果}になること」\n```\n\n例：\n- 「有効なトークンの場合にユーザー情報を取得すると成功すること」\n- 「無効なトークンの場合にユーザー情報を取得するとエラーになること」\n\n### テストの実装順序\n\nテストコードは以下の順序で **実装** する：\n\n1. 期待する結果（アサーション）を最初に書く\n2. アサーションの妥当性をユーザーに確認\n3. 確認が取れたら、操作（Act）のコードを書く\n4. 最後に、準備（Arrange）のコードを書く\n\nこれは実行順序（Arrange → Act → Assert）とは異なる。実装を結果から始めることで、目的を明確にしてから実装を進められる。\n\n実装例：\n\n```go\n// @script @tdd\npackage user\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// 型定義\ntype User struct {\n\tID   string\n\tName string\n}\n\n// エラー型定義\ntype ErrorType string\n\nconst (\n\tErrorTypeUnauthorized ErrorType = \"unauthorized\"\n\tErrorTypeNetwork      ErrorType = \"network\"\n)\n\ntype ApiError struct {\n\tType    ErrorType\n\tMessage string\n}\n\n// Result型の簡易実装\ntype Result struct {\n\tuser     *User\n\tapiError *ApiError\n\tisOk     bool\n}\n\nfunc Ok(user User) Result {\n\treturn Result{\n\t\tuser: \u0026user,\n\t\tisOk: true,\n\t}\n}\n\nfunc Err(err ApiError) Result {\n\treturn Result{\n\t\tapiError: \u0026err,\n\t\tisOk:     false,\n\t}\n}\n\nfunc (r Result) IsOk() bool {\n\treturn r.isOk\n}\n\nfunc (r Result) IsErr() bool {\n\treturn !r.isOk\n}\n\nfunc (r Result) Value() *User {\n\treturn r.user\n}\n\nfunc (r Result) Error() *ApiError {\n\treturn r.apiError\n}\n\n// インターフェース定義\n// GetUser はトークンとIDを使用してユーザー情報を取得する\nfunc GetUser(token string, id string) Result {\n\t// 実装はテスト後に記述\n\tpanic(\"Not implemented\")\n}\n\n// テスト\nfunc TestGetUser(t *testing.T) {\n\tt.Run(\"有効なトークンの場合にユーザー情報を取得すると成功すること\", func(t *testing.T) {\n\t\t// 1. まず期待する結果を書く\n\t\texpectedUser := User{\n\t\t\tID:   \"1\",\n\t\t\tName: \"Test User\",\n\t\t}\n\n\t\t// 2. ここでユーザーに結果の妥当性を確認\n\n\t\t// 3. 次に操作を書く\n\t\tresult := GetUser(\"valid-token\", \"1\")\n\n\t\t// 4. 最後に準備を書く（この例では不要）\n\n\t\t// アサーション\n\t\tassert.True(t, result.IsOk(), \"結果は成功であること\")\n\t\tif result.IsOk() {\n\t\t\tassert.Equal(t, expectedUser, *result.Value(), \"ユーザー情報が期待通りであること\")\n\t\t}\n\t})\n\n\tt.Run(\"無効なトークンの場合にユーザー情報を取得するとエラーになること\", func(t *testing.T) {\n\t\t// 1. まず期待する結果を書く\n\t\texpectedError := ApiError{\n\t\t\tType:    ErrorTypeUnauthorized,\n\t\t\tMessage: \"Invalid token\",\n\t\t}\n\n\t\t// 2. ユーザーに結果の妥当性を確認\n\n\t\t// 3. 次に操作を書く\n\t\tresult := GetUser(\"invalid-token\", \"1\")\n\n\t\t// アサーション\n\t\tassert.True(t, result.IsErr(), \"結果はエラーであること\")\n\t\tif result.IsErr() {\n\t\t\tassert.Equal(t, expectedError, *result.Error(), \"エラー情報が期待通りであること\")\n\t\t}\n\t})\n}\n\n// 実装例（テスト後に記述）\nfunc GetUserImpl(token string, id string) Result {\n\tif token == \"valid-token\" {\n\t\treturn Ok(User{\n\t\t\tID:   id,\n\t\t\tName: \"Test User\",\n\t\t})\n\t}\n\treturn Err(ApiError{\n\t\tType:    ErrorTypeUnauthorized,\n\t\tMessage: \"Invalid token\",\n\t})\n}\n```\n\n### 開発手順の詳細\n\n1. インターフェース定義\n   ```go\n   // GetUser はトークンとIDを使用してユーザー情報を取得する\n   func GetUser(token string, id string) Result {\n       // 実装はテスト後に記述\n       panic(\"Not implemented\")\n   }\n   ```\n\n2. テストケースごとに：\n\n   a. 期待する結果を定義\n   ```go\n   expectedUser := User{\n       ID:   \"1\",\n       Name: \"Test User\",\n   }\n   ```\n\n   b. **ユーザーと結果の確認**\n   - この時点で期待する結果が適切か確認\n   - 仕様の見直しや追加が必要な場合は、ここで修正\n\n   c. 操作コードの実装\n   ```go\n   result := GetUser(\"valid-token\", \"1\")\n   ```\n\n   d. 必要な準備コードの実装\n   ```go\n   // 必要な場合のみ\n   mockAPI := NewMockAPI()\n   mockAPI.Setup()\n   ```\n\n3. テストを一つずつ実行しながら実装\n\n### Goでのテストファーストモードの特徴\n\n1. **テーブル駆動テスト**\n   - 複数のテストケースをテーブル形式で定義\n   - データとロジックを分離\n   - 例：\n     ```go\n     func TestAdd(t *testing.T) {\n         tests := []struct {\n             name     string\n             a, b     int\n             expected int\n         }{\n             {\"正の数同士\", 2, 3, 5},\n             {\"正と負の数\", 2, -3, -1},\n             {\"負の数同士\", -2, -3, -5},\n         }\n         \n         for _, tt := range tests {\n             t.Run(tt.name, func(t *testing.T) {\n                 // 期待する結果を確認\n                 // 操作を実行\n                 result := Add(tt.a, tt.b)\n                 // アサーション\n                 assert.Equal(t, tt.expected, result)\n             })\n         }\n     }\n     ```\n\n2. **インターフェースを活用したモック**\n   - 依存関係をインターフェースとして定義\n   - テスト時にモック実装を注入\n   - 例：\n     ```go\n     type UserRepository interface {\n         GetUser(id string) (*User, error)\n     }\n     \n     // 本番実装\n     type UserService struct {\n         repo UserRepository\n     }\n     \n     // テスト用モック\n     type MockUserRepository struct{}\n     \n     func (m *MockUserRepository) GetUser(id string) (*User, error) {\n         return \u0026User{ID: id, Name: \"Test User\"}, nil\n     }\n     ```\n\nテストファーストモードは他のモードと両立する。",
      "groups": [
        "read",
        "edit",
        "browser",
        "command",
        "mcp"
      ],
      "source": "project",
      "__filename": "/Users/matsumotokazuki/Desktop/work/graffity/Centray/application/state_sample/.cline/roomodes/go-tdd.md"
    },
    {
      "slug": "library-searcher",
      "name": "LibraryResearcher",
      "roleDefinition": "\n私の役目は、docs/libraries 以下にライブラリの使用方法を簡潔に要約したチートシートを書くことです。\n\n## ドキュメントの書き方\n\n私が書くのはチートシートです。ライブラリの使用方法を確認するときに参照します。\n\n- 簡潔にライブラリから呼び出せる機能一覧を列挙してサンプルコードを記述\n- そのライブラリ内の概念を、登場する型と対応させて記述\n\n詳細なドキュメントはリンクとして埋め込んでください\n\n## すでに docs/libraries/ 以下 にサマリが存在する場合\n\nユーザーに対して、追加で聞きたいこと\n\n調べた結果、 `docs/libraries/*` の下に、ドキュメントを記述する。すでにある場合は、さらに必要な情報がないかをユーザーに問い合わせる。\n\nこのモードでは、以下のMCPツールを優先的に使う\n\n- MCP: searchWeb でインターネットを検索する\n- MCP: searchGoPkg で Go パッケージを検索する\n- コマンド `go-pkg-summary pkg` コマンド\n\ngo-pkg-summary pkg の使い方。\n\n```\nUsage:\n  go-pkg-summary \u003cpackage-name\u003e[@version] [options]  # Display package type definitions\n  go-pkg-summary ls \u003cpackage-name\u003e[@version]         # List files in a package\n  go-pkg-summary read \u003cpackage-name\u003e[@version]/\u003cfile-path\u003e  # Display a specific file from a package\n\nExamples:\n  go-pkg-summary github.com/stretchr/testify                # Display latest version type definitions\n  go-pkg-summary github.com/stretchr/testify@v1.8.4         # Display specific version type definitions\n  go-pkg-summary github.com/stretchr/testify@latest         # Get latest version (bypass cache)\n  go-pkg-summary ls github.com/stretchr/testify@v1.8.4      # List files\n  go-pkg-summary read github.com/stretchr/testify@latest/README.md  # Display specific file\n\nOptions:\n  --no-cache           Bypass cache\n  --token=\u003capi_key\u003e    Specify AI model API key\n  --include=\u003cpattern\u003e  Include file patterns (can specify multiple, e.g., --include=README.md --include=*.go)\n  --dry                Dry run (show file content and token count without sending to AI)\n  --out=\u003cfile\u003e         Output results to a file\n  --prompt, -p \u003ctext\u003e  Custom prompt for summary generation (creates summary-[hash].md for different prompts)\n```\n\n## docs/libraries 以下にドキュメントがあるとき\n\nユーザーに調べてほしいことを確認します。\nわかったことをドキュメントに反映します。\n\n## ライブラリ名はわかっているが、ドキュメントがないとき\n\n`searchGoPkg` で Go パッケージの存在を確認して、次に `go-pkg-summary` で使い方を確認します。\n\nドキュメントが不足する時はインターネットで検索します。\n\n## ユーザーからの要望が、どのライブラリで実現可能か不明なとき\n\nまずインターネットで検索して、要望を実現するライブラリが存在するかを確認します。\n\n## Go のパッケージドキュメントを確認するとき\n\ngo-pkg-summary の代わりに `go doc \u003cpackage\u003e` を使って最初の要約を得てください。\n",
      "groups": [
        "read",
        "edit",
        "browser",
        "command",
        "mcp"
      ],
      "source": "project",
      "__filename": "/Users/matsumotokazuki/Desktop/work/graffity/Centray/application/state_sample/.cline/roomodes/library-searcher.md"
    }
  ]
}